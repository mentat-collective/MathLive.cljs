;; # Welcome to [Clerk](https://clerk.vision/)!

^{:nextjournal.clerk/toc true}
(ns {{top/ns}}.{{main/ns}}
    (:require [mentat.clerk-utils.show :refer [show-sci]]
              [nextjournal.clerk :as clerk]))

;; Hello! This project was generated by the [`mathlive/clerk`
;; template](https://mathlive.mentat.org/#project-template). The template comes
;; with everything you need you everything you need to

;; - Interactively develop Clerk notebooks
;; - Publish them to [GitHub Pages](https://pages.github.com/) or [Clerk's Garden](https://github.clerk.garden/)
;; - Use a [custom ClojureScript build](https://clerk-utils.mentat.org/#custom-clojurescript-builds) in both modes

;; Some good next steps:

;; - Visit this project's README.md for guides on how to proceed.
;; - Read the [`MathLive.cljs` documentation notebook](https://mathlive.mentat.org)
;; - Read the [Book of Clerk](https://book.clerk.vision/)
;; - Visit the [Awesome-Clerk](https://github.com/mentat-collective/awesome-clerk) list for ideas
;; - Delete anything in this notebook you feel like you don't need.

;; ## Clerk Environment Basics
;;
;; Here's a basic use of Clerk. This is a function:

(defn hello [s]
  (str "Hello, " s "!"))

;; If we call this function, Clerk will render the form and its output:

(hello "Clerk")

;; - The form `(hello "Clerk")` executes in the JVM.
;; - The resulting string "Hello, Clerk!" is serialized over a WebSocket to the
;;   browser, where Clerk's ClojureScript side renders it using a
;;   pre-registered "viewer".
;; - These viewers are written in code evaluated using the [Small Clojure
;;   Interpreter](https://github.com/babashka/sci), or "SCI".

;; Clerk comes with [many viewers](https://book.clerk.vision/#viewers), and
;; gives us the ability to [write _new_
;; viewers](https://book.clerk.vision/#writing-viewers) using a default SCI
;; environment that Clerk makes available to us.

;; The ["MathLive Clerk Viewer"](#mathlive-clerk-viewer) section gives an
;; example of a custom viewer written using this project's customized SCI
;; environment.

;; ## MathLive Quickstart

;; First, we'll use `clerk/eval-cljs` to install some nice aliases into this
;; notebook's namespace:

(clerk/eval-cljs
 '(require '[reagent.core :as reagent])
 '(require '[mathlive.core :as ml]))

;; > Note that you can also use fully-qualified names of any namespace installed
;; > into SCI via the `myusername.sci-extensions` namespace.

;; Next, customize the style of the `math-field` element backing each
;; `ml/MathField` instance (see [this
;; guide](https://mathlive.mentat.org#styling) for more detail here):

(show-sci
 [:style "
math-field {
  font-size: 24px;
  border-radius: 4px;
  border: 1px solid;
  padding: 8px;
}
math-field:focus-within {
  outline: none;
  border: 1px solid blue;
}"])

;; The following snippet implements the example from the ["Controlled
;; Component"](https://mathlive.mentat.org/#controlled-component) section of
;; the [`MathLive.cljs` docs
;; notebook](https://mathlive.mentat.org/#controlled-component). Type into the
;; field and note the change in TeX output below:

(show-sci
 (reagent/with-let
   [!tex      (reagent/atom "1+\\cos(x)^2")
    on-change #(reset! !tex (.getValue (.-target %)))]
   [:<>
    [ml/Mathfield
     {:value     @!tex
      :on-change on-change}]
    [:pre @!tex]]))

;; ## MathLive Clerk Viewer

;; Here's an example of a viewer that lets us instantiate a `MathLive.cljs`
;; field using data from the JVM. This viewer takes a `view-box` argument from
;; the JVM and passes it as a property to the `mafs/Mafs` component:

(def mathlive-viewer
  {:transform-fn clerk/mark-presented
   :render-fn
   '(fn [mathjson]
      [ml/Mathfield
       {:ref (fn [mf]
               (when mf
                 (doto mf
                   (ml/set-math-json! mathjson))))}])})

;; Apply it here:

^{::clerk/viewer mathlive-viewer}
["Add" "x" ["Subtract" "y" "z"]]

;; Re-use this viewer with a different MathJSON:

^{::clerk/viewer mathlive-viewer}
["Multiply" "z" ["Exp" "y"]]


;; ## Shared Client / Server State

;; Clerk has the ability to synchronize state between client and server. Declare
;; an atom tagged with `::clerk/sync` to create an atom on both server and
;; client:

^::clerk/sync
(defonce !shared
  (atom "1+\\cos(x)^2"))

;; Configure a `ml/MathField` instance with `!shared`:

(show-sci
 (let [on-change #(reset! !shared (.getValue (.-target %)))]
   [:<>
    [ml/Mathfield
     {:value     @!shared
      :on-change on-change}]
    [:pre @!shared]]))

;; Manipulating this field will trigger updates on the client:

(show-sci
 [nextjournal.clerk.viewer/inspect @!shared])

;; And _also_ on the server. Note that the following form isn't surrounded by
;; `show-sci`:

@!shared

;; If you have a REPL open, any updates you make to the text inside `!shared`
;; will cause immediate updates to the `MathField` you see.
